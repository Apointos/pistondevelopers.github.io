var searchIndex = {};
searchIndex['hgl'] = {"items":[[0,"","hgl","hgl-rs - helpers for working with OpenGL."],[2,"Primitive","",""],[12,"Points","","",0],[12,"Lines","","",0],[12,"LineStrip","","",0],[12,"LineLoop","","",0],[12,"Triangles","","",0],[12,"TriangleStrip","","",0],[12,"TriangleFan","","",0],[3,"restart_index","","A simple wrapper for glPrimitiveRestartIndex."],[0,"program","","Dealing with Programs and Shaders"],[1,"Shader","hgl::program",""],[11,"name","","",1],[11,"type_","","",1],[1,"Program","","A program, which consists of multiple compiled shaders \"linked\" together"],[11,"name","","",2],[2,"ShaderType","","Shader types"],[12,"VertexShader","","",3],[12,"FragmentShader","","",3],[10,"to_glenum","","Convert a ShaderType into its corresponding GL value",3],[10,"from_name","","",1],[10,"name","","Returns the name (id) of the shader.",1],[10,"compile","","Compile a shader.",1],[10,"from_file","","",1],[10,"drop","","",1],[10,"link","","Link shaders into a program",2],[10,"bind","","",2],[10,"bind_frag","","",2],[10,"uniform","","",2],[10,"get_name","","",2],[10,"drop","","",2],[0,"buffer","hgl",""],[1,"Vbo","hgl::buffer","A vertex buffer object"],[11,"name","","",4],[1,"Ebo","","An Element Buffer Object, aka GL_ELEMENT_ARRAY_BUFFER."],[11,"name","","",5],[2,"BufferUsage","","Frequency with which the vbo is expected to be updated"],[12,"StaticDraw","","Updated once, drawn many times",6],[12,"DynamicDraw","","Updated many times, drawn many times",6],[12,"StreamDraw","","Updated once, drawn once",6],[10,"drop","","",4],[10,"to_glenum","","",6],[10,"new","","Generate a new VBO, without binding it.",4],[10,"from_data","","Generate a new VBO and upload `data` to it.",4],[10,"load_data","","Load data into this vbo.",4],[10,"bind","","",4],[10,"new","","Create a new EBO, without binding it.",5],[10,"from_indices","","Create an EBO from a slice of indices.",5],[10,"load_data","","Load new index data into this EBO.",5],[10,"bind","","",5],[0,"query","hgl",""],[1,"Query","hgl::query",""],[11,"name","","",7],[11,"target","","",7],[2,"QueryTarget","",""],[12,"SamplesPassed","","",8],[10,"to_glenum","","",8],[10,"new","","",7],[10,"begin","","",7],[10,"end","","",7],[10,"result_available","","",7],[10,"result","","",7],[10,"drop","","",7],[0,"vao","hgl",""],[1,"Vao","hgl::vao","A vertex array object"],[11,"name","","",9],[10,"drop","","",9],[10,"new","","",9],[10,"bind","","",9],[10,"enable_attrib","","Define and enable an array of generic vertex attribute data for `name`\nin `program`, in this VAO, using the bound VBO.  TODO: Normalize\nhardcoded to GL_FALSE.",9],[10,"enable_int_attrib","","As enable_attrib, but using glVertexAttribIPointer",9],[10,"enable_double_attrib","","As enable_attrib, but using glVertexAttribLPointer",9],[10,"disable_attrib","","",9],[10,"draw_array","","Draw the given primitive, using `count` vertices starting at offset\n`first` in the currently bound VBO.",9],[10,"draw_elements","","Draw the given primitive, using `count` vertices starting at offset\n`first` in the currently bound EBO.",9],[0,"texture","hgl",""],[1,"ImageInfo","hgl::texture","ImageInfo represents the non-data parameters to glTexImage*, with the goal\nof making the numerous arguments more readable."],[11,"level","","",10],[11,"internal_format","","",10],[11,"width","","",10],[11,"height","","",10],[11,"depth","","",10],[11,"format","","",10],[11,"ptype","","",10],[1,"SubImageInfo","","SubImageInfo represents the non-data parameters to glTexSubImage*, with\nthe goal of making the numerous arguments more readable."],[11,"level","","",11],[11,"width","","",11],[11,"height","","",11],[11,"depth","","",11],[11,"xoffset","","",11],[11,"yoffset","","",11],[11,"zoffset","","",11],[11,"format","","",11],[11,"ptype","","",11],[1,"Texture","","A texture object."],[11,"name","","",12],[11,"target","","",12],[2,"TextureTarget","",""],[12,"Texture1D","","",13],[12,"Texture2D","","",13],[12,"Texture3D","","",13],[12,"Texture1DArray","","",13],[12,"Texture2DArray","","",13],[12,"TextureRectangle","","",13],[12,"TextureCubeMap","","Note: cube maps aren't entirely supported quite yet. Can't use\nTexImage with them.",13],[12,"TextureBuffer","","",13],[2,"WrapMode","",""],[12,"ClampToEdge","","",14],[12,"ClampToBorder","","",14],[12,"Repeat","","",14],[12,"MirroredRepeat","","",14],[2,"FilterMethod","",""],[12,"Nearest","","",15],[12,"Linear","","",15],[12,"NearestMipmapNearest","","",15],[12,"LinearMipmapNearest","","",15],[12,"NearestMipmapLinear","","",15],[12,"LinearMipmapLinear","","",15],[0,"pixel","","Enums for pixel format and pixel types, for pixel transfers (particularly in textures)."],[2,"PixelFormat","hgl::texture::pixel",""],[12,"RED","","",16],[12,"RG","","",16],[12,"RGB","","",16],[12,"BGR","","",16],[12,"RGBA","","",16],[12,"BGRA","","",16],[2,"PixelType","",""],[12,"UNSIGNED_BYTE","","",17],[12,"BYTE","","",17],[12,"UNSIGNED_SHORT","","",17],[12,"SHORT","","",17],[12,"UNSIGNED_INT","","",17],[12,"INT","","",17],[12,"FLOAT","","",17],[12,"UNSIGNED_BYTE_3_3_2","","",17],[12,"UNSIGNED_BYTE_2_3_3_REV","","",17],[12,"UNSIGNED_SHORT_5_6_5","","",17],[12,"UNSIGNED_SHORT_5_6_5_REV","","",17],[12,"UNSIGNED_SHORT_4_4_4_4","","",17],[12,"UNSIGNED_SHORT_4_4_4_4_REV","","",17],[12,"UNSIGNED_SHORT_5_5_5_1","","",17],[12,"UNSIGNED_SHORT_1_5_5_5_REV","","",17],[12,"UNSIGNED_INT_8_8_8_8","","",17],[12,"UNSIGNED_INT_8_8_8_8_REV","","",17],[12,"UNSIGNED_INT_10_10_10_2","","",17],[12,"UNSIGNED_INT_2_10_10_10_REV","","",17],[10,"to_glenum","","",16],[10,"to_glenum","","",17],[10,"to_glenum","hgl::texture","",13],[10,"to_glenum","","",14],[10,"to_glenum","","",15],[10,"new","","Create a new ImageInfo where everything is set to a \"good default\",\nthat is, RGBA with the data type being bytes.",10],[10,"level","","Set the mipmap level",10],[10,"width","","Set the width. 1D textures only have width.",10],[10,"height","","Set the height. 2D and 3D textures require this.",10],[10,"depth","","Set the depth. Only 3D textures have depth.",10],[10,"pixel_format","","Set the pixel data format",10],[10,"pixel_type","","Set the pixel data type",10],[10,"internal_format","","Set the internal format",10],[10,"new","","Create a new SubImageInfo where everything is set to a \"good default\",\nthat is, RGBA with the data type being bytes.",11],[10,"level","","Set the mipmap level",11],[10,"width","","Set the width. 1D textures only have width.",11],[10,"height","","Set the height. 2D and 3D textures require this.",11],[10,"depth","","Set the depth. Only 3D textures have depth.",11],[10,"xoffset","","Set the X offset into the texture. 1D textures only have an X offset.",11],[10,"yoffset","","Set the Y offset into the texture. 2D and 3D textures require this.",11],[10,"zoffset","","Set the Z offset into the texture. Only 3D textures have a Z offset.",11],[10,"pixel_format","","Set the pixel data format",11],[10,"pixel_type","","Set the pixel data type",11],[10,"new","","Create a new texture and load an image into it.  Note that even if\nyour data isn't GL_BYTE, you can pass a *u8 anyway since the GL\ndoesn't care about the type.",12],[10,"new_raw","","Create a texture without binding it.",12],[10,"bind","","",12],[10,"wrap","","",12],[10,"wrap_s","","",12],[10,"wrap_t","","",12],[10,"wrap_r","","",12],[10,"border_color","","",12],[10,"filter","","",12],[10,"min_filter","","",12],[10,"mag_filter","","",12],[10,"gen_mipmaps","","SAFETY NOTE: You *must* call `load_data` before calling this method.\nBad Things will happen otherwise.",12],[10,"load_image","","Load an image into this texture.",12],[10,"load_subimage","","Load an image into part of this texture.",12],[10,"activate","","Bind this texture to texture unit `num` (GL_TEXTURE0 + num)",12],[10,"drop","","",12],[10,"to_glenum","hgl","",0]],"paths":[[2,"Primitive"],[1,"Shader"],[1,"Program"],[2,"ShaderType"],[1,"Vbo"],[1,"Ebo"],[2,"BufferUsage"],[1,"Query"],[2,"QueryTarget"],[1,"Vao"],[1,"ImageInfo"],[1,"SubImageInfo"],[1,"Texture"],[2,"TextureTarget"],[2,"WrapMode"],[2,"FilterMethod"],[2,"PixelFormat"],[2,"PixelType"]]};
initSearch(searchIndex);
